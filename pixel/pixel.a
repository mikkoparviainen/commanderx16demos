!to "pixel.prg", cbm

verareg=$9f20
veralo  = verareg+0
veramid = verareg+1
verahi  = verareg+2
veradat = verareg+3
veradat2= verareg+4
veractl = verareg+5
veraien = verareg+6
veraisr = verareg+7

vreg_cmp  = $F0000
vreg_pal  = $F1000
vreg_lay1 = $F2000
vreg_lay2 = $F3000
vreg_spr  = $F4000
vreg_sprd = $F5000

pixlo = $FB
pixmid = pixlo+1
pixhi = pixmid+1

*=$0801
	!byte $0b,$08,$01,$00,$9e,$32,$30,$36,$31,$00,$00,$00

	jsr vera_init_320x240_8bpp ; set 8bpp bitmap mode
	lda #01
	sta colour
	jsr clear_screen

	lda #00
	sta colour

	lda #$00
	tay
-	tya
	sta x
	sta y
	jsr draw_pixel
	iny
	cpy #$FE
	bne -

	lda #$5
	sta colour
	lda #0
	sta x
	sta y
	jsr draw_pixel

	; randomize pixels
-	lda #<320
	sta bound
	lda #>320
	sta bound+1 
	jsr getrandom_bounded
	lda brandom
	sta x
	lda brandom+1
	sta x+1

	lda #<240
	sta bound
	lda #>240
	sta bound+1
	jsr getrandom_bounded
	lda brandom
	sta y
	lda brandom+1
	sta y+1

	jsr getrandom_bounded
	lda random
	sta colour
	jsr draw_pixel
	jmp -

	rts

; parameters for the pixel - faster to do it this way
x: !byte $00, $00
y: !byte $00, $00

draw_pixel:
	; assumes that y < 512 x < 512
	lda #$00
	sta pixhi
	sta pixmid
	sta pixlo ; empty working area

	lda y
	sta pixmid
	lda y+1
	sta pixhi ; pixlo-pixmid-pixhi = 256 * y

	lda y
	asl
	asl
	asl
	asl
	asl
	asl
	sta pixlo ; pixlo = 64 * y
	
	lda y
	lsr
	lsr 
	clc
	adc pixmid
	sta pixmid
	lda #0
	adc pixhi
	sta pixhi ; pixmid:pixhi += 64 * y

	lda y+1
	asl
	asl
	asl
	asl
	asl
	asl
	clc
	adc pixmid
	lda #0
	adc pixhi

	; now pixlo:pixmid:pixhi = 320 * y

	lda x
	clc
	adc pixlo
	sta pixlo
	lda x+1
	adc pixmid
	sta pixmid
	lda #0
	adc pixhi
	sta pixhi  ; pixlo:pixmid:pixhi += x

	lda pixlo
	sta veralo
	lda pixmid
	sta veramid
	lda pixhi
	sta verahi ; veralo:veramid:verahi = pos of pixel, inc=0

	lda colour
	sta veradat ; print pixel

	rts

vera_init_320x240_8bpp:
	 lda #$0
	 sta veramid
	 lda #$0F
	 sta verahi ; $F0000 
	 lda #$01
	 sta veralo ; $F0001
	 lda #64 ; HSCALE = 64 -> 2 pixels per write
	 sta veradat
	 lda #$02 ; $F0002
	 sta veralo
	 lda #64 
	 sta veradat ; VSCALE = 64 -> 2 pixels per write

	 lda #$0
	 sta veralo
	 lda #$20
	 sta veramid
	 lda #$0F 
	 sta verahi ; $F2000, increment 0 - layer 0 register 0
	 lda #$E1 ; mode bitmap 8bpp, enabled 
	 sta veradat ; set mode
	 lda #$01 
	 sta veralo ; $F2001
	 lda #$00
	 sta veradat ; TILEW=0  -> 320 px
	 lda #$04
	 sta veralo
	 lda #0
	 sta veradat ; TILEBASE_LO = 0
	 lda #$05
	 sta veralo
	 lda #0
	 sta veradat ; TILEBASE_HI = 0

	 rts

text_mode:
	rts

clear_screen:
	lda #$0
	sta veralo
	sta veramid
	lda #$10
	sta verahi ; $00000, increment 1
	lda #$FF
	tay
--	lda #$F0
	tax
	lda colour
-	sta veradat
	dex
	bne -
	dey
    beq +
    jmp --
+   lda #65
	tay
--	lda #$F0
	tax
	lda colour
-	sta veradat
	dex
	bne -
	dey
    beq +
    jmp --

+	rts

colour: !byte $00

bound: !byte $00, $00
brandom: !byte $00, $00
; this bounds the rng value to bound
; assumes bound < 512 which it is for our graph demo purposes
getrandom_bounded:
-	jsr getrandom
	lda random
	sta brandom
	lda random+1
	and #$01 ; we only ever need the first bit of the higher byte
	         ; as we know what we're doing
	sta brandom+1

	lda bound+1
	cmp brandom+1
	bcc - ; upper byte of bound was less than random -> random too big, again
	beq + ; upper byte of bound was the same as random -> needs to compare lower byte
	jmp ++ ; upper byte of bound was more than random -> all okay, go away
+	lda bound
	cmp brandom
	bcc - ; lower byte of bound was more than random -> random too big, again
++	rts   ; all okay, go back, bounded in brandom and brandom+1

;---------------------------------------------------------------------------
;pseudo-random routine, value in random+1 (akku also) and random
;source: https://codebase64.org/doku.php?id=base:16bit_pseudo_random_generator
;---------------------------------------------------------------------------
getrandom:

         lda random+1
         sta tempr
         lda random
         asl
         rol tempr
         asl
         rol tempr
         clc
         adc random
         pha
         lda tempr
         adc random+1
         sta random+1
         pla
         adc #$11
         sta random
         lda random+1
         adc #$36
         sta random+1

         rts

tempr:   !byte $5a
random:  !byte %10011101,%01011011